package golang

import (
	"fmt"
	"io"
	"strings"

	"github.com/serenize/snaker"

	"github.com/dave/jennifer/jen"
	"github.com/reflect/errawr-gen/doc"
)

const (
	runtime = "github.com/reflect/errawr-go"
)

type Error struct {
	Section    Section
	Name       string
	GoName     string
	Definition doc.DocumentError
}

type Section struct {
	Name       string
	GoName     string
	Definition doc.DocumentSection
}

type FileGenerator struct {
	pkg string
	doc *doc.Document
	f   *jen.File
}

func (fg *FileGenerator) init() {
	fg.f.PackageComment(fmt.Sprintf("Package %s contains errors for the domain %q.", fg.pkg, fg.doc.Domain.Key))
	fg.f.PackageComment("")
	fg.f.PackageComment("This file is automatically generated by reflect-errors. Do not modify it.")

	// Create a type for the domain.
	fg.f.Comment("Domain is the general domain in which all errors in this package belong.")
	fg.f.Var().Id("Domain").Op("=").Op("&").Qual(runtime, "ErrorDomain").Values(jen.Dict{
		jen.Id("Key"):   jen.Lit(fg.doc.Domain.Key),
		jen.Id("Title"): jen.Lit(fg.doc.Domain.Title),
	})
	fg.f.Line()
}

func (fg *FileGenerator) def(def Error) {
	// Create the builder type.
	builderTypeName := fmt.Sprintf(`%s%sBuilder`, def.Section.GoName, def.GoName)

	fg.f.Commentf(`%s is a builder for %q errors.`, builderTypeName, def.Name)
	fg.f.Type().Id(builderTypeName).Struct(jen.Id("arguments").Qual(runtime, "ErrorArguments"))
	fg.f.Line()

	// Create builder methods for all optional arguments.
	for _, a := range def.Definition.OrderedArguments {
		if !a.Argument.IsOptional() {
			continue
		}

		withFuncName := fmt.Sprintf(`With%s`, snaker.SnakeToCamel(a.Name))

		description := a.Argument.Description
		if description == "" {
			description = fmt.Sprintf("the %q argument", a.Name)
		}

		fg.f.Commentf(`%s sets %s in this builder.`, withFuncName, description)
		fg.f.Func().Params(
			jen.Id("b").Op("*").Id(builderTypeName),
		).Id(withFuncName).Params(
			jen.Id("value").String(),
		).Op("*").Id(builderTypeName).Block(
			jen.Id("b").Dot("arguments").Index(jen.Lit(a.Name)).Dot("Set").Call(jen.Id("value")),
			jen.Return(jen.Id("b")),
		)
		fg.f.Line()
	}

	// Create final Build() method.
	fg.f.Commentf(`Build creates the error for the code %q from this builder.`, def.Name)
	fg.f.Func().Params(
		jen.Id("b").Op("*").Id(builderTypeName),
	).Id("Build").Params().Qual(runtime, "Error").BlockFunc(func(g *jen.Group) {
		// Add runtime argument validation.
		for _, a := range def.Definition.OrderedArguments {
			if a.Argument == nil || len(a.Argument.Validators) == 0 {
				continue
			}

			for _, validator := range a.Argument.Validators {
				g.Id("b").Dot("arguments").Index(jen.Lit(a.Name)).Dot("Validate").Call(jen.Lit(validator))
			}
			g.Line()
		}

		g.Id("description").Op(":=").Op("&").Qual(runtime, "ErrorDescription").Values(jen.Dict{
			jen.Id("Friendly"):  jen.Lit(strings.TrimSpace(def.Definition.Description.Friendly)),
			jen.Id("Technical"): jen.Lit(strings.TrimSpace(def.Definition.Description.Technical)),
		})
		g.Line()

		g.Id("err").Op(":=").Op("&").Qual(runtime, "GeneralError").Values(jen.Dict{
			jen.Id("Domain"):      jen.Id("Domain"),
			jen.Id("Section"):     jen.Id(fmt.Sprintf(`%sSection`, def.Section.GoName)),
			jen.Id("Code"):        jen.Lit(def.Name),
			jen.Id("Title"):       jen.Lit(def.Definition.Title),
			jen.Id("Description"): jen.Id("description"),
			jen.Id("Arguments"):   jen.Id("b").Dot("arguments"),
		})
		g.Return(jen.Id("err"))
	})
	fg.f.Line()

	// Create constructors.
	constructorFuncName := fmt.Sprintf(`New%s`, builderTypeName)
	params := func(g *jen.Group) {
		for _, a := range def.Definition.OrderedArguments {
			if a.Argument.IsOptional() {
				continue
			}

			g.Id(a.Name).String()
		}
	}

	fg.f.Commentf(`%s creates a new error builder for the code %q.`, constructorFuncName, def.Name)
	fg.f.Func().Id(constructorFuncName).ParamsFunc(params).Op("*").Id(builderTypeName).Block(
		jen.Return(jen.Op("&").Id(builderTypeName).Values(jen.Dict{
			jen.Id("arguments"): jen.Qual(runtime, "ErrorArguments").Values(jen.DictFunc(func(d jen.Dict) {
				for _, a := range def.Definition.OrderedArguments {
					d[jen.Lit(a.Name)] = jen.Qual(runtime, "NewErrorArgument").Call(jen.Do(func(s *jen.Statement) {
						if a.Argument.IsOptional() {
							s.Lit(*a.Argument.Default)
						} else {
							s.Id(a.Name)
						}
					}), jen.LitFunc(func() interface{} {
						if a.Argument == nil {
							return ""
						}

						return a.Argument.Description
					}))
				}
			})),
		})),
	)
	fg.f.Line()

	defaultFuncName := fmt.Sprintf(`New%s%s`, def.Section.GoName, def.GoName)

	fg.f.Commentf(`%s creates a new error with the code %q.`, defaultFuncName, def.Name)
	fg.f.Func().Id(defaultFuncName).ParamsFunc(params).Qual(runtime, "Error").Block(
		jen.Return(
			jen.Id(constructorFuncName).CallFunc(func(g *jen.Group) {
				for _, a := range def.Definition.OrderedArguments {
					if a.Argument.IsOptional() {
						continue
					}

					g.Id(a.Name)
				}
			}).Dot("Build").Call(),
		),
	)
	fg.f.Line()
}

func (fg *FileGenerator) section(section Section) {
	// Create a type for the section.
	sectionTypeName := fmt.Sprintf(`%sSection`, section.GoName)

	fg.f.Commentf(`%s defines a section of errors with the following scope:`, sectionTypeName)
	fg.f.Comment(section.Definition.Title)
	fg.f.Var().Id(sectionTypeName).Op("=").Op("&").Qual(runtime, "ErrorSection").Values(jen.Dict{
		jen.Id("Key"):   jen.Lit(section.Name),
		jen.Id("Title"): jen.Lit(section.Definition.Title),
	})
	fg.f.Line()

	for name, def := range section.Definition.Errors {
		fg.def(Error{
			Section:    section,
			Name:       name,
			GoName:     snaker.SnakeToCamel(name),
			Definition: def,
		})
	}
}

func (fg *FileGenerator) all() {
	for name, section := range fg.doc.Sections {
		fg.section(Section{
			Name:       name,
			GoName:     snaker.SnakeToCamel(name),
			Definition: section,
		})
	}
}

func (fg *FileGenerator) Render(w io.Writer) error {
	return fg.f.Render(w)
}

func NewFileGenerator(pkg string, document *doc.Document) *FileGenerator {
	fg := &FileGenerator{
		pkg: pkg,
		doc: document,
		f:   jen.NewFile(pkg),
	}
	fg.init()
	fg.all()

	return fg
}
